<html>
    <head>
        <style>
            .redval{color: #aa0000; width: 30px; height: 22px;}
            .greenval{color: #00aa00; width: 30px; height: 22px;}
            .blueval{color: #0000aa; width: 30px; height: 22px;}
            .colorvaluebox{display: inline-block; width: 60px; height: 22px;}
            #colorbox{float: left;}
            #color-table{width: 650px;}
            #color-table-box{float: right; width: 275px;}
        </style>
    </head>
    <body>
        <img id="gifbox" src="test.gif"/>
        <div id="colorbox" style="float:left">
        <input id="file-input" type="file" name="name" onchange="readFile()"/>
        <button id="download" style="display: none;">Download</button>
        <br/>
        <button class="zero" id="red" style="display: none;">Zero Red</button>
        <button class="zero" id="green" style="display: none;">Zero Green</button>
        <button class="zero" id="blue" style="display: none;">Zero Blue</button><br/>
        <button class="random" id="randred" style="display: none;">Random Red</button>
        <button class="random" id="randgreen" style="display: none;">Random Green</button>
        <button class="random" id="randblue" style="display: none;">Random Blue</button><br/>
            <div id="color-table-box"></div>
            <div id="color-table"></div>
            
        </div>
    </body>
    <script>
     const toBase64 = file => new Promise((resolve, reject) => {
         const reader = new FileReader();
         reader.readAsDataURL(file);
         reader.onload = () => resolve(reader.result);
         reader.onerror = error => reject(error);
     });

     const toBytes = base64String => {
         // remove metadata from dataUrl
         let dataString = base64String.split(",")[1];

         let binary = window.atob(dataString);
         var array = new Uint8Array(binary.length);
         for( var i = 0; i < binary.length; i++ ) {
             array[i] = binary.charCodeAt(i)
         }
         return array;
     }

     const toHex = bytes => {
         return Array.prototype.map.call(new Uint8Array(bytes.buffer), x => ('00' + x.toString(16)).slice(-2));
     }

     const findByteRange = bytes => {
         let flagsByte = bytes[10];
         let globalColorTableSizeBits = [
             (flagsByte & (1 << 6)) === 0 ? 0 : 1,
             (flagsByte & (1 << 7)) === 0 ? 0 : 1,
             (flagsByte & (1 << 8)) === 0 ? 0 : 1,
         ];
         colorTableSize = 3 * 2**(parseInt(globalColorTableSizeBits.join(''), 2) + 1);
         return [13, 13 + colorTableSize];
     }

     const displayDownloadButton = onClick => {
         element = document.querySelector('#download');
         element.onclick = onClick
         element.style = "";
     }

     const updateColorTable = (colorTable, callback) => {
         return event => {
             newValue = event.target.value;
             idx = parseInt(event.target.id);
             colorTable[idx] = newValue;
             callback();
         }
     }

     const zeroColorChannel = (colorTable, colorChannel, callback) => {
         var idx;
         if (colorChannel === "red") {
             idx = 0;
         } else if (colorChannel === "green") {
             idx = 1;
         } else if (colorChannel === "blue") {
             idx = 2;
         }
         for(var i = idx; i < colorTable.length; i = i+3) {
             colorTable[i] = '00'
         }
         callback()
     }

     const renderZeroButtons = (colorTable, callback) => {
         buttons = document.querySelectorAll('.zero');
         buttons.forEach(button => {
             button.style = "";
             let colorChannel = button.id
             button.onclick = () => {
                 zeroColorChannel(
                     colorTable,
                     colorChannel,
                     callback
             )};
         });
     }

     const randomColorChannel = (colorTable, colorChannel, callback) => {
         var idx;
         if (colorChannel === "randred") {
             idx = 0;
         } else if (colorChannel === "randgreen") {
             idx = 1;
         } else if (colorChannel === "randblue") {
             idx = 2;
         }
         for(var i = idx; i < colorTable.length; i = i+3) {
             colorTable[i] = Math.floor(Math.random()*256).toString(16).padStart(2, '0');
         }
         callback()
     }

     const renderRandomButtons = (colorTable, callback) => {
         buttons = document.querySelectorAll('.random');
         buttons.forEach(button => {
             button.style = "";
             let colorChannel = button.id
             button.onclick = () => {
                 randomColorChannel(
                     colorTable,
                     colorChannel,
                     callback
             )};
         });
     }

     const updateBytes = (bytes, colorTable, byteRange) => {
         for(var i = byteRange[0]; i < byteRange[1]; i++) {
             bytes[i] = parseInt(colorTable[i - byteRange[0]], 16);
         }

     }

     const onDownloadClick = (bytes, colorTable, byteRange) => {
         updateBytes(bytes, colorTable, byteRange)
         let charsArr = []
         for(var i = 0; i < bytes.length; i++) {
             charsArr.push(String.fromCharCode(bytes[i]))
         }
         let chars = charsArr.join('')
         let dataString = window.btoa(chars);
         let base64String = 'data:image/gif;base64,' + dataString;
         let a = document.createElement("a");
         a.href = base64String;
         a.download = "result.gif";
         a.click();
     }

     const renderColorTableHTML = (colorTable, callback) => {
         let colorTableList = document.querySelector('#color-table');
         colorTableList.innerHTML = "";
         colorTable.forEach((element, idx) => {
             input = document.createElement("input");
             input.id = idx;
             input.type = "text";
             input.value = element;
             switch(idx % 3) {
                 case 0: 
                   input.setAttribute("class", "redval");
                   break;
                 case 1:
                   input.setAttribute("class", "greenval");
                   break;
                 case 2:
                   input.setAttribute("class", "blueval");
                 }
             input.onchange = updateColorTable(colorTable, callback);
             colorTableList.appendChild(input);
         });
     }

     const renderColorTableBox = (colorTable, callback) => {
         let colorTableListBox = document.querySelector('#color-table-box');
         colorTableListBox.innerHTML = "";
         var colorTableColor = [];
         var dumb;
         for (var i=0; i<colorTable.length; i+=3) {
             colorTableColor.push(colorTable.slice(i,i+3));
         }
         // there must be a better way than to use innerHTML like this
         colorTableColor.forEach((element, idx) => {
             input = document.createElement("span");
             input.setAttribute("class", "colorvaluebox")
             input.id = "color" + idx;
             // element has commas
             input.innerHTML = element;
             // assign as innerHTML and then strip out commas
             dumb = "#" + input.innerHTML.replace(/,/g,'');
             input.innerHTML = dumb;
             input.style.backgroundColor = dumb;
             colorTableListBox.appendChild(document.createTextNode (" "));
             colorTableListBox.appendChild(input);
         });
     }

     const colorTableUpdated = (bytes, colorTable, byteRange) => {
         return () => {
             renderColorTableHTML(
                 colorTable,
                 colorTableUpdated(bytes, colorTable, byteRange)
             );
             renderColorTableBox(
                 colorTable,
                 colorTableUpdated(bytes, colorTable, byteRange)
             );
             displayDownloadButton(() => {
                 onDownloadClick(bytes, colorTable, byteRange)
             })
             newGif(bytes, colorTable, byteRange);
         }
     }

     async function readFile() {
         let file = document.querySelector('#file-input').files[0];
         let base64String = await toBase64(file);
         let bytes = toBytes(base64String)
         let byteRange = findByteRange(bytes)
         let hex = toHex(bytes)
         let colorTable = hex.slice(byteRange[0], byteRange[1])
         let callback = colorTableUpdated(bytes, colorTable, byteRange)
         renderColorTableHTML(colorTable, callback);
         renderColorTableBox(colorTable, callback);
         renderZeroButtons(colorTable, callback);
         renderRandomButtons(colorTable, callback);
         newGif(bytes, colorTable, byteRange);
     }

     function renderGif(gif) {
         document.getElementById("gifbox").src = gif;
     }

     const newGif = (bytes, colorTable, byteRange) => {
         updateBytes(bytes, colorTable, byteRange)
         let charsArr = []
         for(var i = 0; i < bytes.length; i++) {
             charsArr.push(String.fromCharCode(bytes[i]))
         }
         let chars = charsArr.join('')
         let dataString = window.btoa(chars);
         let base64String = 'data:image/gif;base64,' + dataString;
         let a = document.createElement("a");
         a.href = base64String;
         document.getElementById("gifbox").src = a;
     }
    </script>
</html>
